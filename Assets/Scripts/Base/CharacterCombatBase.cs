using System;using GGG.Tool;using Manager;using ScriptObjects;using Unilts.Tools.DevelopmentTool;using UnityEngine;using UnityEngine.Serialization;namespace Base{    public class CharacterCombatBase : MonoBehaviour    {        protected Animator Anim;        [SerializeField] protected Transform currentEnemy;                [SerializeField, Header("角色组合技")] protected CharacterCombo baseCombo;        [SerializeField, Header("处决攻击")] protected CharacterCombo finishCombo;        protected CharacterCombo CurrentCombo;        [SerializeField] private float animationCrossNormalTime;        protected int CurrentComboIndex;        protected int HitIndex;        protected int FinishComboIndex;        protected int CurrentComboCount;                protected float MaxColdTime;        protected bool CanAttackInput;        protected bool CanFinish;        protected virtual void Awake()        {            Anim = GetComponent<Animator>();        }        protected virtual void Update()        {            MatchPosition();            LookTargetOnAttack();            OnEndAttack();        }        /// <summary>        /// 角色朝向攻击目标        /// </summary>        protected void LookTargetOnAttack()        {            if (currentEnemy == null) return;            if (DevelopmentToos.DistanceForTarget(currentEnemy, transform) > 5f) return;            if (Anim.AnimationAtTag("Attack") && Anim.GetCurrentAnimatorStateInfo(0).normalizedTime < 0.5f)            {                //动画未执行到一半                // transform.rotation = Quaternion.LookRotation(currentEnemy.position);                transform.Look(currentEnemy.position, 50f);            }        }                protected virtual void MatchPosition()        {            if (currentEnemy == null) return;            if (!Anim) return;                        else if (Anim.AnimationAtTag("Attack"))            {                var timer = Anim.GetCurrentAnimatorStateInfo(0).normalizedTime;                if (timer > 0.35f) return;                if (DevelopmentToos.DistanceForTarget(currentEnemy, transform) > 2f) return;                //当前不处于匹配期间                if (!Anim.isMatchingTarget && !Anim.IsInTransition(0))                {                    Anim.MatchTarget(                        currentEnemy.position +                        (-transform.forward * CurrentCombo.TryGetComboPosition(CurrentComboIndex)), Quaternion.identity ,  AvatarTarget.Body,                        new MatchTargetWeightMask(Vector3.one, 0f), 0, 0.35f);                }            }        }        protected void RunningMatch(CharacterCombo combo, int index ,float startTime = 0f, float endTime = 0.01f)        {            if (!Anim.isMatchingTarget && Anim.IsInTransition(0))            {                Anim.MatchTarget(                    currentEnemy.position +                    (-transform.forward * combo.TryGetComboPosition(index)),                    Quaternion.identity, AvatarTarget.Body, new MatchTargetWeightMask(Vector3.one, 0f), startTime,                    endTime);            }        }                /// <summary>        /// 动画触发攻击事件        /// </summary>        private void Atk()        {            TriggerDamage();            UpdateHitIndex();            GamePoolManager.MainInstance.TryGetPoolItem("AtkSound", transform.position, Quaternion.identity);        }        protected virtual void CharacterBaseAttackInput()        {                    }                /// <summary>        /// 伤害触发        /// </summary>        private void TriggerDamage()        {            if (currentEnemy == null) return;            //判断敌人方向距离            if (Vector3.Dot(transform.forward, DevelopmentToos.DirectionForTarget(transform, currentEnemy)) <                0.85f) return;            if (DevelopmentToos.DistanceForTarget(transform, currentEnemy) > 1.3f) return;            if (Anim.AnimationAtTag("Attack"))            {                GameEventManager.MainInstance.CallEvent("TakeDamage",                    CurrentCombo.TryGetComboDamage(CurrentComboIndex),                    CurrentCombo.TryGetOneHitName(CurrentComboIndex, HitIndex),                    CurrentCombo.TryGetOneParryName(CurrentComboIndex, HitIndex), transform, currentEnemy);            }            else            {                //进行处决动画                GameEventManager.MainInstance.CallEvent("CreateDamage",                    finishCombo.TryGetComboDamage(FinishComboIndex), currentEnemy);            }        }                /// <summary>        /// 更新连招        /// </summary>        protected virtual void UpdateComboInfo()        {            CurrentComboIndex++;            if (CurrentComboIndex == CurrentCombo.TryComboMaxCount())            {                CurrentComboIndex = 0;            }            MaxColdTime = 0f;            CanAttackInput = true;        }                /// <summary>        /// 更新受击动画        /// </summary>        private void UpdateHitIndex()        {            HitIndex++;            Debug.Log(CurrentComboIndex);            if (HitIndex == CurrentCombo.TryGetHitMaxCount(CurrentComboIndex))                HitIndex = 0;        }                protected void ResetComboInfo()        {            CurrentComboIndex = 0;            MaxColdTime = 0;            HitIndex = 0;        }        /// <summary>        /// 重置连招        /// </summary>        protected void OnEndAttack()        {            if (Anim.AnimationAtTag("Motion") && CanAttackInput)            {                ResetComboInfo();            }        }                /// <summary>        /// 退出连招        /// </summary>        protected void ExecuteComboAction()        {            //更新当前Hit的索引值            HitIndex = 0;            CurrentComboCount += (CurrentCombo == baseCombo) ? 1 : 0;            if (CurrentComboIndex == CurrentCombo.TryComboMaxCount())            {                //当前攻击动作为最后一个动作                CurrentComboIndex = 0;            }            MaxColdTime = CurrentCombo.TryGetColdTime(CurrentComboIndex);            Anim.CrossFadeInFixedTime(CurrentCombo.TryGetOneComboAction(CurrentComboIndex), 0.1555f, 0, 0f);            TimeManager.MainInstance.TryGetOneTimer(MaxColdTime, UpdateComboInfo);            CanAttackInput = false;        }                /// <summary>        /// 更换出招表格        /// </summary>        /// <param name="comboData"></param>        protected void ChangeComboData(CharacterCombo comboData)        {            if (CurrentCombo != comboData)            {                CurrentCombo = comboData;                ResetComboInfo();            }        }    }}